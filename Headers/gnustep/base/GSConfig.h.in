/* Machine/OS specific configuration information for GNUstep

   Please NOTE - GSConfig.h is generated by the configure script from the
   file GSConfig.h.in - changes/fixes need to be made to the original file,
   not to the GSConfig.h generated from it.

   Copyright (C) 1998,1999 Free Software Foundation, Inc.

   Written by:  Richard frith-Macdonald <richard@brainstorm.co.uk>

   This file is part of the GNUstep Base Library.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
   */

#ifndef	included_GSConfig_h
#define	included_GSConfig_h

/* An alternate to GS_FAKE_MAIN which forces the user to call the 
   NSProcessInfo initialization in 'main', GS_FAKE_MAIN must also
   be undefined. */
#if @GS_PASS_ARGUMENTS@
#define GS_PASS_ARGUMENTS @GS_PASS_ARGUMENTS@
#endif

#define GS_FAKE_MAIN	@GS_FAKE_MAIN@
#if	GS_FAKE_MAIN

/*
 * NOTE - if GS_FAKE_MAIN (above) is set to 1, this hack applies - and you
 * must make sure that this file is included in any file that implements
 * the 'main()' function and links with the GNUstep base libarary.
 * You should NOT include this file in a program that does not link with
 * the base library.
 * This file is included automatically in NSObject.h and Foundation.h
 *
 * The Foundation classe NSProcessInfo need access to the argc, argv,
 * and env variables of the main() function. The purpose of this (ugly hack)
 * definition is to give the gstep-base library the opportunity to implement
 * its own main function with private access to the global vars. The private
 * main() implementation (in NSProcessInfo.m) will then call the user defined
 * gnustep_base_user_main() function.
 *
 * The original hack was -
 ** Written by:  Georg Tuparev, EMBL & Academia Naturalis,
 **              Heidelberg, Germany
 **              Tuparev@EMBL-Heidelberg.de
 **
 **  NOTE! This is very dirty and dangerous trick. I spend several hours
 ** on thinking and man pages browsing, but couldn't find better solution.
 ** I know that I will spend 666 years in the Computer Hell for writing
 ** this hack, and the master devil (Bully Boy) will send me to write
 ** Windowz software.
 ** BTW, for writing this hack I got personal congratulations from Dennis
 ** Ritchie and Bjarne Stroustrup sent me a bunch of flowers and asked me
 ** to participate in the standardization committee for C-- v.6.0 as
 ** responsible for the new Tab-Overriding-Operator and Scope-Sensitive-
 ** Comments ... but this makes my situation even worse ;-)
 ** - Georg
 *
 * On some systems, there are other relatively clean workarounds, if this
 * applies to the system you are running on, your configuration script
 * should have set GS_FAKE_MAIN to zero, so that this define hack will
 * not be used.
 */

#define main gnustep_base_user_main
extern int gnustep_base_user_main (/* int argc, char *argv[] */);

#endif	/* GS_FAKE_MAIN */


/*
 * Definition to specify if your processor stores words with the most
 * significant byte first (like Motorola and SPARC, unlike Intel and VAX).
 */
#define GS_WORDS_BIGENDIAN	@GS_WORDS_BIGENDIAN@

/*
 *	Size definitions for standard types
 */
#define	GS_SIZEOF_SHORT		@ac_cv_sizeof_short@
#define	GS_SIZEOF_INT		@ac_cv_sizeof_int@
#define	GS_SIZEOF_LONG		@ac_cv_sizeof_long@
#define	GS_SIZEOF_LONG_LONG	@ac_cv_sizeof_long_long@
#define	GS_SIZEOF_FLOAT		@ac_cv_sizeof_float@
#define	GS_SIZEOF_DOUBLE	@ac_cv_sizeof_double@
#define	GS_SIZEOF_VOIDP		@ac_cv_sizeof_voidp@

/*
 *	Size information to be places in bits 5 and 6 of type encoding bytes
 *	in archives (bits 0 to 4 are used for basic type info and bit 7 is
 *	used to mark cross-references to previously encoded objects).
 */
#define	_GSC_S_SHT	@_GSC_S_SHT@
#define	_GSC_S_INT	@_GSC_S_INT@
#define	_GSC_S_LNG	@_GSC_S_LNG@
#define	_GSC_S_LNG_LNG	@_GSC_S_LNG_LNG@

/*
 * Type definitions for types with known sizes.
 */
typedef @GS_SINT8@ gss8;
typedef @GS_UINT8@ gsu8;
typedef @GS_SINT16@ gss16;
typedef @GS_UINT16@ gsu16;
typedef @GS_SINT32@ gss32;
typedef @GS_UINT32@ gsu32;
typedef @GS_SINT64@ gss64;
typedef @GS_UINT64@ gsu64;
typedef @GS_SINT128@ gss128;
typedef @GS_UINT128@ gsu128;
typedef @GS_FLT32@ gsf32;
typedef @GS_FLT64@ gsf64;

/*
 * Integer type with same size as a pointer
 */
typedef	@GS_ADDR@ gsaddr;

/*
 *	Do we have real 64-bit and 128-bit integers or are we just pretending.
 */
#define GS_HAVE_I64	@GS_HAVE_I64@
#define GS_HAVE_I128	@GS_HAVE_I128@

/*
 *	Do we have the GNU Multiple-precision library for NSDecimal?
 */
//#define HAVE_GMP	@HAVE_GMP@
#define HAVE_GMP	0

/*
 * Macros to deal with hiding an object from the garbage collector
 * This macro employs the procesor-dependent knowledge that a pointer to an
 * object will always be on an even address boundary.  If we ever port to a
 * system where this is not the case, we will have to find another mechanism.
 */
#ifndef	GS_WITH_GC
#define	GS_WITH_GC	0
#endif
#if	GS_WITH_GC
#define	GS_GC_HIDE(obj)		((id)(((gsaddr)obj) | 1))
#define	GS_GC_UNHIDE(obj)	((id)(((gsaddr)obj) & ~1))
#else
#define	GS_GC_HIDE(obj)		((id)obj)
#define	GS_GC_UNHIDE(obj)	((id)obj)
#endif

/*
 * Define to say if we use NXConstantString or NSConstantString
 */
#define NXConstantString	@NX_CONST_STRING_CLASS@

#endif	/* included_GSConfig_h */

